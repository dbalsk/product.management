# **상품 관리 애플리케이션**
> 리스트로 관리되는 **상품 관리 애플리케이션**을 만들어보며 **도메인 주도 설계**, **의존성 주입** 등을 학습하고 프로젝트 개발 실습을 진행해보자.
  
## 애플리케이션
    
**✔ 요구사항**
- 상품을 관리하는 애플리케이션
- 상품은 **상품 번호**, **상품 이름**, **가격**, **재고 수량**의 네 가지 정보가짐
- **상품 번호**는 1부터 시작하여 상품이 추가될 때마다 1씩 증가 /  중복허용x
- **상품 이름**은 1~100글자의 문자열 / 중복허용
- **가격**은 0~1,000,000원
- **재고 수량**은 0~9999개 
- 행동 
    - **상품 추가**
        - 단건으로 하나씩 추가 
    - **상품 조회**
        - 상품 번호 기준으로 하나의 상품 조회
        - 전체 상품 목록 조회
        - 상품 이름의 특정 문자열 기준으로 검색 
    - **상품 수정**
        - 상품 번호 기준으로 상품 번호 제외한 나머지 정보 수정
    - **상품 제거**
        - 상품 번호 기준으로 특정 상품 제거


**✔ 데이터구조 정의 (상품 클래스 정의)**
- 상품: **Product** -> 클래스
- 상품 번호: **id** -> Long (**식별자**이기에 Long으로)
- 상품 이름: **name** ->String
- 가격: **price** -> Integer
- 재고 수량: **amount** -> Integer

>+래퍼클래스로 선언 이유      
해당 래퍼런스 변수가 **null 값**(정의되지 않은 상태)을 가질 수 있고 
**컬렉션의 요소**로도 사용할 수 있기에 모든 필드를 프리미티브 타입이 아닌
래퍼 클래스로 선언. 

## 프로젝트 구조
**✔ [도메인 주도 설계 (Domain Driven Design)](https://github.com/dbalsk/TIL/blob/main/SpringBoot/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EC%84%A4%EA%B3%84.md)**  


**✔ 빈 등록 / 의존성 설계**   
스프링 프레임워크를 사용하여 클래스를 생성하고 의존성을 주입한다. 
1. 주입될 의존성(클래스)를 **빈으로 등록**  
    - 방법: 클래스에 특정 이노테이션(@Service, @Repository, @RestController 등)을 추가
2. 빈으로 등록된 **의존성**(클래스)를 사용할 곳에 **주입**    
    - 방법: **생성자 주입** (사용할 곳에서 의존성을 클래스 변수로 선언, 
    @Autowired를 붙인 생성자로 주입)

**✔ Dto (Data Transfer Object)**  
데이터를 전송하는 역할을 가진 객체 / 데이터 구조의 분리를 위해 사용   

ex) 위 프로젝트에 Dto를 사용하지 않을 경우, 도메인 객체 "Product"가 표현/응용/인프라스트럭처 계층에 모두 사용됨.   
("Product" 변경 시 모든 계층이 영향을 받게됨.)  
1. 표현 계층에 **"ProductDto"** 추가 (Product에서 getter 가져옴 -> 도메인 객체 캡슐화) 
2. "ProductDto"가 표현/응용 계층까지 역할, 인프라스트럭처 계층은 "Product" 사용     
    -> ProductDto와 Product의 변환 필요 (**Dto - 엔티티 변환**)  
    -> getter없이 변환이 가능한 **ModelMapper 매핑 라이브러리** 사용 

>+[Dto/엔티티](https://github.com/dbalsk/TIL/blob/main/SpringBoot/Dto-%EC%97%94%ED%8B%B0%ED%8B%B0.md)

## 상품 추가 기능 구현
- 컨트롤러
    - **POST** 메소드
- 레포지토리 
    - **리스트 생성**: 스레드 안전성이 있는 CopyOnWriteArrayList를 사용 (멀티스레드 환경이기에)  
    - **id 추가**: 데이터베이스의 id관리를 위해 **레포지토리에서 id 관리** / 스레드 안전성이 있는 AtomicLong 사용 
    - **add 메소드**: id를 가져와 1을 증가하여 set해주고 리스트에 추가하는 메소드
- 엔티티
    - **setter 추가**: id 관리 책임을 레포지토리로 가져갔기에 외부에서 id 설정 필요  
    (캡슐화가 깨지기에 setter 사용을 지양해야하지만, 위 경우는 데이터베이스에서 id 사용을 위한 트레이드 오프)
## 상품 조회 기능 구현 (번호 기준 조회)
- 컨트롤러 
    - **GET** 메소드
    - **패스 베리어블**: id(특정자원) 조회이기에 패스 베리어블 사용
- 레포지토리 
    - **findById 메소드**: 스트림 API로 같은 id를 필터로 거르는 메소드
- 엔티티
    - **sameId 메소드**: id가 같은지 확인하는 메소드 
## 상품 조회 기능 구현 (문자열 검색) (+전체상품 조회)
- 컨트롤러 
    - **GET** 메소드
    - **쿼리 파라메터**: 문자열 검색(일종의 필터)이기에 쿼리 파라메터 사용
    - 쿼리 파라메터 넘어올 경우 findByNameContaining 사용 / 넘어오지 않을 경우 findAll 사용
- 레포지토리 
    - **findByNameContaining 메소드**: 스트림 API로 동일한 문자열 지닌 객체를 필터로 거르는 메소드 (문자열 검색 구현)
    - **findAll 메소드**: Product 리스트를 반환하는 메소드 (전체상품 조회 구현)
- 엔티티
    - **containsName 메소드**: 동일한 문자열 확인하는 메소드 
    >+containsName 사용이유  
    >getter로 name을 레포지토리로 가져왔다면 여러 곳에 값을 중복 사용하여 객체지향적 코드가 아니게됨.  
    >또한 도메인의 지식이 상품 내부에서 빠져나가 코드만으로 요구사항 파악 불가
    
## 상품 수정 기능 구현
- 컨트롤러 
    - **PUT** 메소드
    - **패스 베리어블**: id(특정자원) 지칭이기에 패스 베리어블 사용
    - **RequestBody**: 요청바디를 통해 상품에 대한 JSON을 받기위해 사용용  
- 레포지토리 
    - **update 메소드**: (setter를 사용하여 인스턴스 값을 변경하는 방식을 사용하지 않고) **인스턴스 자체를 변경**하는 메소드
        - indexOf 메소드: **동일한 인스턴스**를 찾아 인덱스를 반환하는 메소드 (동일 판단 기준은 equals 메소드)
        - set 메소드: 해당 인덱스의 인스턴스에 **요청바디로 받아온 객체를 넣어** 변경하는 메소드 
- 엔티티
    - **equals 메소드**: id값이 같다면 동일 인스턴스로 판단하도록 오버라이드

## 상품 삭제 기능 구현
- 컨트롤러 
    - **DELETE** 메소드
    - **패스 베리어블**: id(특정자원) 지칭이기에 패스 베리어블 사용
- 레포지토리 
    - **delete 메소드**: findById 메소드를 재사용하여 객체를 찾고 remove 메소드로 해당 객체를 리스트에서 삭제
>+소프트딜리트  
>사용자에게 삭제된 것으로 보이지만 내부적으로는 삭제하지 않아야 할 경우에 사용. 보통 Boolean 타입 필드로 참일 경우 조회안되게 하여(삭제된 것처럼) 구현.
</br>

## 유효성 검사 
**✔ [유효성 검사 / 전역 예외 핸들러](https://github.com/dbalsk/TIL/blob/main/SpringBoot/%EC%9C%A0%ED%9A%A8%EC%84%B1%EA%B2%80%EC%82%AC.md)**
- **도메인 객체에 대한 유효성 검사**와 **컨트롤러에 대한 유효성 검사**를 각각의 성격에 맞게 진행
- 발생한 예외에 대해 **전역 예외 핸들러**를 추가하여 처리 

</br>

## 참고자료
[이것이백엔드개발이다](https://product.kyobobook.co.kr/detail/S000211834105)  
